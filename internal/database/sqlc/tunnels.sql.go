// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tunnels.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const checkPublicPortAvailability = `-- name: CheckPublicPortAvailability :one
SELECT COUNT(*) FROM tunnels 
WHERE public_port = $1 AND status = 'active'
`

func (q *Queries) CheckPublicPortAvailability(ctx context.Context, publicPort pgtype.Int4) (int64, error) {
	row := q.db.QueryRow(ctx, checkPublicPortAvailability, publicPort)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const checkSubdomainAvailability = `-- name: CheckSubdomainAvailability :one
SELECT COUNT(*) FROM tunnels 
WHERE subdomain = $1 AND status = 'active'
`

func (q *Queries) CheckSubdomainAvailability(ctx context.Context, subdomain pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, checkSubdomainAvailability, subdomain)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countActiveTunnelsByUser = `-- name: CountActiveTunnelsByUser :one
SELECT COUNT(*) FROM tunnels WHERE user_id = $1 AND status = 'active'
`

func (q *Queries) CountActiveTunnelsByUser(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countActiveTunnelsByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTunnelsByUser = `-- name: CountTunnelsByUser :one
SELECT COUNT(*) FROM tunnels WHERE user_id = $1
`

func (q *Queries) CountTunnelsByUser(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countTunnelsByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTunnel = `-- name: CreateTunnel :one
INSERT INTO tunnels (
    user_id, name, protocol, subdomain, custom_domain, target_host, target_port, 
    public_port, status, auth_token, max_connections, expires_at, metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
) RETURNING id, user_id, name, protocol, subdomain, custom_domain, target_host, target_port, public_port, status, auth_token, max_connections, expires_at, metadata, created_at, updated_at
`

type CreateTunnelParams struct {
	UserID         uuid.UUID        `db:"user_id" json:"user_id"`
	Name           string             `db:"name" json:"name"`
	Protocol       string             `db:"protocol" json:"protocol"`
	Subdomain      pgtype.Text        `db:"subdomain" json:"subdomain"`
	CustomDomain   pgtype.Text        `db:"custom_domain" json:"custom_domain"`
	TargetHost     string             `db:"target_host" json:"target_host"`
	TargetPort     int32              `db:"target_port" json:"target_port"`
	PublicPort     *int32              `db:"public_port" json:"public_port,omitempty"`
	Status         string             `db:"status" json:"status"`
	AuthToken      pgtype.Text        `db:"auth_token" json:"auth_token"`
	MaxConnections pgtype.Int4        `db:"max_connections" json:"max_connections"`
	ExpiresAt      pgtype.Timestamptz `db:"expires_at" json:"expires_at"`
	Metadata       []byte             `db:"metadata" json:"metadata"`
}

func (q *Queries) CreateTunnel(ctx context.Context, arg CreateTunnelParams) (Tunnels, error) {
	row := q.db.QueryRow(ctx, createTunnel,
		arg.UserID,
		arg.Name,
		arg.Protocol,
		arg.Subdomain,
		arg.CustomDomain,
		arg.TargetHost,
		arg.TargetPort,
		arg.PublicPort,
		arg.Status,
		arg.AuthToken,
		arg.MaxConnections,
		arg.ExpiresAt,
		arg.Metadata,
	)
	var i Tunnels
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Protocol,
		&i.Subdomain,
		&i.CustomDomain,
		&i.TargetHost,
		&i.TargetPort,
		&i.PublicPort,
		&i.Status,
		&i.AuthToken,
		&i.MaxConnections,
		&i.ExpiresAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteExpiredTunnels = `-- name: DeleteExpiredTunnels :exec
DELETE FROM tunnels WHERE expires_at IS NOT NULL AND expires_at < NOW()
`

func (q *Queries) DeleteExpiredTunnels(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredTunnels)
	return err
}

const deleteTunnel = `-- name: DeleteTunnel :exec
DELETE FROM tunnels WHERE id = $1 AND user_id = $2
`

type DeleteTunnelParams struct {
	ID     uuid.UUID `db:"id" json:"id"`
	UserID uuid.UUID `db:"user_id" json:"user_id"`
}

func (q *Queries) DeleteTunnel(ctx context.Context, arg DeleteTunnelParams) error {
	_, err := q.db.Exec(ctx, deleteTunnel, arg.ID, arg.UserID)
	return err
}

const getNextAvailablePort = `-- name: GetNextAvailablePort :one
SELECT COALESCE(MIN(port_num), 0) as next_port
FROM generate_series($1, $2) AS port_num
WHERE port_num NOT IN (
    SELECT public_port FROM tunnels 
    WHERE public_port IS NOT NULL AND status = 'active'
)
`

type GetNextAvailablePortParams struct {
	GenerateSeries   pgtype.Numeric `db:"generate_series" json:"generate_series"`
	GenerateSeries_2 pgtype.Numeric `db:"generate_series_2" json:"generate_series_2"`
}

func (q *Queries) GetNextAvailablePort(ctx context.Context, arg GetNextAvailablePortParams) (interface{}, error) {
	row := q.db.QueryRow(ctx, getNextAvailablePort, arg.GenerateSeries, arg.GenerateSeries_2)
	var next_port interface{}
	err := row.Scan(&next_port)
	return next_port, err
}

const getTunnelByID = `-- name: GetTunnelByID :one
SELECT id, user_id, name, protocol, subdomain, custom_domain, target_host, target_port, public_port, status, auth_token, max_connections, expires_at, metadata, created_at, updated_at FROM tunnels WHERE id = $1
`

func (q *Queries) GetTunnelByID(ctx context.Context, id uuid.UUID) (Tunnels, error) {
	row := q.db.QueryRow(ctx, getTunnelByID, id)
	var i Tunnels
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Protocol,
		&i.Subdomain,
		&i.CustomDomain,
		&i.TargetHost,
		&i.TargetPort,
		&i.PublicPort,
		&i.Status,
		&i.AuthToken,
		&i.MaxConnections,
		&i.ExpiresAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTunnelByPublicPort = `-- name: GetTunnelByPublicPort :one
SELECT id, user_id, name, protocol, subdomain, custom_domain, target_host, target_port, public_port, status, auth_token, max_connections, expires_at, metadata, created_at, updated_at FROM tunnels WHERE public_port = $1 AND status = 'active'
`

func (q *Queries) GetTunnelByPublicPort(ctx context.Context, publicPort pgtype.Int4) (Tunnels, error) {
	row := q.db.QueryRow(ctx, getTunnelByPublicPort, publicPort)
	var i Tunnels
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Protocol,
		&i.Subdomain,
		&i.CustomDomain,
		&i.TargetHost,
		&i.TargetPort,
		&i.PublicPort,
		&i.Status,
		&i.AuthToken,
		&i.MaxConnections,
		&i.ExpiresAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTunnelBySubdomain = `-- name: GetTunnelBySubdomain :one
SELECT id, user_id, name, protocol, subdomain, custom_domain, target_host, target_port, public_port, status, auth_token, max_connections, expires_at, metadata, created_at, updated_at FROM tunnels WHERE subdomain = $1 AND status = 'active'
`

func (q *Queries) GetTunnelBySubdomain(ctx context.Context, subdomain pgtype.Text) (Tunnels, error) {
	row := q.db.QueryRow(ctx, getTunnelBySubdomain, subdomain)
	var i Tunnels
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Protocol,
		&i.Subdomain,
		&i.CustomDomain,
		&i.TargetHost,
		&i.TargetPort,
		&i.PublicPort,
		&i.Status,
		&i.AuthToken,
		&i.MaxConnections,
		&i.ExpiresAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTunnelsByStatus = `-- name: GetTunnelsByStatus :many
SELECT id, user_id, name, protocol, subdomain, custom_domain, target_host, target_port, public_port, status, auth_token, max_connections, expires_at, metadata, created_at, updated_at FROM tunnels WHERE status = $1 ORDER BY created_at DESC
`

func (q *Queries) GetTunnelsByStatus(ctx context.Context, status string) ([]Tunnels, error) {
	rows, err := q.db.Query(ctx, getTunnelsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tunnels{}
	for rows.Next() {
		var i Tunnels
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Protocol,
			&i.Subdomain,
			&i.CustomDomain,
			&i.TargetHost,
			&i.TargetPort,
			&i.PublicPort,
			&i.Status,
			&i.AuthToken,
			&i.MaxConnections,
			&i.ExpiresAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveTunnels = `-- name: ListActiveTunnels :many
SELECT id, user_id, name, protocol, subdomain, custom_domain, target_host, target_port, public_port, status, auth_token, max_connections, expires_at, metadata, created_at, updated_at FROM tunnels 
WHERE status = 'active'
ORDER BY created_at DESC
`

func (q *Queries) ListActiveTunnels(ctx context.Context) ([]Tunnels, error) {
	rows, err := q.db.Query(ctx, listActiveTunnels)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tunnels{}
	for rows.Next() {
		var i Tunnels
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Protocol,
			&i.Subdomain,
			&i.CustomDomain,
			&i.TargetHost,
			&i.TargetPort,
			&i.PublicPort,
			&i.Status,
			&i.AuthToken,
			&i.MaxConnections,
			&i.ExpiresAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTunnelsByUser = `-- name: ListTunnelsByUser :many
SELECT id, user_id, name, protocol, subdomain, custom_domain, target_host, target_port, public_port, status, auth_token, max_connections, expires_at, metadata, created_at, updated_at FROM tunnels 
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListTunnelsByUserParams struct {
	UserID uuid.UUID `db:"user_id" json:"user_id"`
	Limit  int32       `db:"limit" json:"limit"`
	Offset int32       `db:"offset" json:"offset"`
}

func (q *Queries) ListTunnelsByUser(ctx context.Context, arg ListTunnelsByUserParams) ([]Tunnels, error) {
	rows, err := q.db.Query(ctx, listTunnelsByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tunnels{}
	for rows.Next() {
		var i Tunnels
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Protocol,
			&i.Subdomain,
			&i.CustomDomain,
			&i.TargetHost,
			&i.TargetPort,
			&i.PublicPort,
			&i.Status,
			&i.AuthToken,
			&i.MaxConnections,
			&i.ExpiresAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTunnel = `-- name: UpdateTunnel :one
UPDATE tunnels 
SET name = $2, target_host = $3, target_port = $4, max_connections = $5, 
    expires_at = $6, metadata = $7, updated_at = NOW()
WHERE id = $1 AND user_id = $8
RETURNING id, user_id, name, protocol, subdomain, custom_domain, target_host, target_port, public_port, status, auth_token, max_connections, expires_at, metadata, created_at, updated_at
`

type UpdateTunnelParams struct {
	ID             uuid.UUID        `db:"id" json:"id"`
	Name           string             `db:"name" json:"name"`
	TargetHost     string             `db:"target_host" json:"target_host"`
	TargetPort     int32              `db:"target_port" json:"target_port"`
	MaxConnections pgtype.Int4        `db:"max_connections" json:"max_connections"`
	ExpiresAt      pgtype.Timestamptz `db:"expires_at" json:"expires_at"`
	Metadata       []byte             `db:"metadata" json:"metadata"`
	UserID         uuid.UUID        `db:"user_id" json:"user_id"`
}

func (q *Queries) UpdateTunnel(ctx context.Context, arg UpdateTunnelParams) (Tunnels, error) {
	row := q.db.QueryRow(ctx, updateTunnel,
		arg.ID,
		arg.Name,
		arg.TargetHost,
		arg.TargetPort,
		arg.MaxConnections,
		arg.ExpiresAt,
		arg.Metadata,
		arg.UserID,
	)
	var i Tunnels
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Protocol,
		&i.Subdomain,
		&i.CustomDomain,
		&i.TargetHost,
		&i.TargetPort,
		&i.PublicPort,
		&i.Status,
		&i.AuthToken,
		&i.MaxConnections,
		&i.ExpiresAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateTunnelStatus = `-- name: UpdateTunnelStatus :exec
UPDATE tunnels 
SET status = $2, updated_at = NOW()
WHERE id = $1
`

type UpdateTunnelStatusParams struct {
	ID     uuid.UUID `db:"id" json:"id"`
	Status string      `db:"status" json:"status"`
}

func (q *Queries) UpdateTunnelStatus(ctx context.Context, arg UpdateTunnelStatusParams) error {
	_, err := q.db.Exec(ctx, updateTunnelStatus, arg.ID, arg.Status)
	return err
}
