// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: users.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countUsers = `-- name: CountUsers :one
SELECT COUNT(*) FROM users WHERE is_active = true
`

func (q *Queries) CountUsers(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countUsers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    email, password_hash, name, role, is_active, email_verified
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, email, password_hash, name, role, is_active, email_verified, email_verification_token, password_reset_token, password_reset_expires_at, last_login_at, failed_login_attempts, locked_until, created_at, updated_at
`

type CreateUserParams struct {
	Email         string `db:"email" json:"email"`
	PasswordHash  string `db:"password_hash" json:"password_hash"`
	Name          string `db:"name" json:"name"`
	Role          string `db:"role" json:"role"`
	IsActive      bool   `db:"is_active" json:"is_active"`
	EmailVerified bool   `db:"email_verified" json:"email_verified"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (Users, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Email,
		arg.PasswordHash,
		arg.Name,
		arg.Role,
		arg.IsActive,
		arg.EmailVerified,
	)
	var i Users
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.Name,
		&i.Role,
		&i.IsActive,
		&i.EmailVerified,
		&i.EmailVerificationToken,
		&i.PasswordResetToken,
		&i.PasswordResetExpiresAt,
		&i.LastLoginAt,
		&i.FailedLoginAttempts,
		&i.LockedUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deactivateUser = `-- name: DeactivateUser :exec
UPDATE users 
SET is_active = false, updated_at = NOW()
WHERE id = $1
`

func (q *Queries) DeactivateUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deactivateUser, id)
	return err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, password_hash, name, role, is_active, email_verified, email_verification_token, password_reset_token, password_reset_expires_at, last_login_at, failed_login_attempts, locked_until, created_at, updated_at FROM users WHERE email = $1 AND is_active = true
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (Users, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i Users
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.Name,
		&i.Role,
		&i.IsActive,
		&i.EmailVerified,
		&i.EmailVerificationToken,
		&i.PasswordResetToken,
		&i.PasswordResetExpiresAt,
		&i.LastLoginAt,
		&i.FailedLoginAttempts,
		&i.LockedUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, email, password_hash, name, role, is_active, email_verified, email_verification_token, password_reset_token, password_reset_expires_at, last_login_at, failed_login_attempts, locked_until, created_at, updated_at FROM users WHERE id = $1 AND is_active = true
`

func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (Users, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i Users
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.Name,
		&i.Role,
		&i.IsActive,
		&i.EmailVerified,
		&i.EmailVerificationToken,
		&i.PasswordResetToken,
		&i.PasswordResetExpiresAt,
		&i.LastLoginAt,
		&i.FailedLoginAttempts,
		&i.LockedUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const incrementFailedLoginAttempts = `-- name: IncrementFailedLoginAttempts :exec
UPDATE users 
SET failed_login_attempts = failed_login_attempts + 1, updated_at = NOW()
WHERE email = $1
`

func (q *Queries) IncrementFailedLoginAttempts(ctx context.Context, email string) error {
	_, err := q.db.Exec(ctx, incrementFailedLoginAttempts, email)
	return err
}

const listUsers = `-- name: ListUsers :many
SELECT id, email, password_hash, name, role, is_active, email_verified, email_verification_token, password_reset_token, password_reset_expires_at, last_login_at, failed_login_attempts, locked_until, created_at, updated_at FROM users 
WHERE is_active = true
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListUsersParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) ListUsers(ctx context.Context, arg ListUsersParams) ([]Users, error) {
	rows, err := q.db.Query(ctx, listUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Users{}
	for rows.Next() {
		var i Users
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.PasswordHash,
			&i.Name,
			&i.Role,
			&i.IsActive,
			&i.EmailVerified,
			&i.EmailVerificationToken,
			&i.PasswordResetToken,
			&i.PasswordResetExpiresAt,
			&i.LastLoginAt,
			&i.FailedLoginAttempts,
			&i.LockedUntil,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const lockUser = `-- name: LockUser :exec
UPDATE users 
SET locked_until = $2, updated_at = NOW()
WHERE email = $1
`

type LockUserParams struct {
	Email       string             `db:"email" json:"email"`
	LockedUntil pgtype.Timestamptz `db:"locked_until" json:"locked_until"`
}

func (q *Queries) LockUser(ctx context.Context, arg LockUserParams) error {
	_, err := q.db.Exec(ctx, lockUser, arg.Email, arg.LockedUntil)
	return err
}

const resetPassword = `-- name: ResetPassword :exec
UPDATE users 
SET password_hash = $2, password_reset_token = NULL, password_reset_expires_at = NULL, updated_at = NOW()
WHERE password_reset_token = $1 AND password_reset_expires_at > NOW()
`

type ResetPasswordParams struct {
	PasswordResetToken pgtype.Text `db:"password_reset_token" json:"password_reset_token"`
	PasswordHash       string      `db:"password_hash" json:"password_hash"`
}

func (q *Queries) ResetPassword(ctx context.Context, arg ResetPasswordParams) error {
	_, err := q.db.Exec(ctx, resetPassword, arg.PasswordResetToken, arg.PasswordHash)
	return err
}

const setEmailVerificationToken = `-- name: SetEmailVerificationToken :exec
UPDATE users 
SET email_verification_token = $2, updated_at = NOW()
WHERE id = $1
`

type SetEmailVerificationTokenParams struct {
	ID                     uuid.UUID `db:"id" json:"id"`
	EmailVerificationToken pgtype.Text `db:"email_verification_token" json:"email_verification_token"`
}

func (q *Queries) SetEmailVerificationToken(ctx context.Context, arg SetEmailVerificationTokenParams) error {
	_, err := q.db.Exec(ctx, setEmailVerificationToken, arg.ID, arg.EmailVerificationToken)
	return err
}

const setPasswordResetToken = `-- name: SetPasswordResetToken :exec
UPDATE users 
SET password_reset_token = $2, password_reset_expires_at = $3, updated_at = NOW()
WHERE email = $1
`

type SetPasswordResetTokenParams struct {
	Email                  string             `db:"email" json:"email"`
	PasswordResetToken     pgtype.Text        `db:"password_reset_token" json:"password_reset_token"`
	PasswordResetExpiresAt pgtype.Timestamptz `db:"password_reset_expires_at" json:"password_reset_expires_at"`
}

func (q *Queries) SetPasswordResetToken(ctx context.Context, arg SetPasswordResetTokenParams) error {
	_, err := q.db.Exec(ctx, setPasswordResetToken, arg.Email, arg.PasswordResetToken, arg.PasswordResetExpiresAt)
	return err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users 
SET name = $2, email = $3, role = $4, email_verified = $5, updated_at = NOW()
WHERE id = $1 AND is_active = true
RETURNING id, email, password_hash, name, role, is_active, email_verified, email_verification_token, password_reset_token, password_reset_expires_at, last_login_at, failed_login_attempts, locked_until, created_at, updated_at
`

type UpdateUserParams struct {
	ID            uuid.UUID `db:"id" json:"id"`
	Name          string      `db:"name" json:"name"`
	Email         string      `db:"email" json:"email"`
	Role          string      `db:"role" json:"role"`
	EmailVerified bool        `db:"email_verified" json:"email_verified"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (Users, error) {
	row := q.db.QueryRow(ctx, updateUser,
		arg.ID,
		arg.Name,
		arg.Email,
		arg.Role,
		arg.EmailVerified,
	)
	var i Users
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.Name,
		&i.Role,
		&i.IsActive,
		&i.EmailVerified,
		&i.EmailVerificationToken,
		&i.PasswordResetToken,
		&i.PasswordResetExpiresAt,
		&i.LastLoginAt,
		&i.FailedLoginAttempts,
		&i.LockedUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserLastLogin = `-- name: UpdateUserLastLogin :exec
UPDATE users 
SET last_login_at = NOW(), failed_login_attempts = 0, locked_until = NULL, updated_at = NOW()
WHERE id = $1
`

func (q *Queries) UpdateUserLastLogin(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, updateUserLastLogin, id)
	return err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE users 
SET password_hash = $2, updated_at = NOW()
WHERE id = $1 AND is_active = true
`

type UpdateUserPasswordParams struct {
	ID           uuid.UUID `db:"id" json:"id"`
	PasswordHash string      `db:"password_hash" json:"password_hash"`
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.Exec(ctx, updateUserPassword, arg.ID, arg.PasswordHash)
	return err
}

const verifyEmail = `-- name: VerifyEmail :exec
UPDATE users 
SET email_verified = true, email_verification_token = NULL, updated_at = NOW()
WHERE email_verification_token = $1
`

func (q *Queries) VerifyEmail(ctx context.Context, emailVerificationToken pgtype.Text) error {
	_, err := q.db.Exec(ctx, verifyEmail, emailVerificationToken)
	return err
}
