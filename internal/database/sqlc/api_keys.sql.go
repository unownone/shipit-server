// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: api_keys.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countAPIKeysByUser = `-- name: CountAPIKeysByUser :one
SELECT COUNT(*) FROM api_keys 
WHERE user_id = $1 AND is_active = true
`

func (q *Queries) CountAPIKeysByUser(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countAPIKeysByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAPIKey = `-- name: CreateAPIKey :one
INSERT INTO api_keys (
    user_id, name, prefix, hash, expires_at, scopes
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, user_id, name, prefix, hash, is_active, last_used_at, expires_at, scopes, created_at, updated_at
`

type CreateAPIKeyParams struct {
	UserID    uuid.UUID        `db:"user_id" json:"user_id"`
	Name      string             `db:"name" json:"name"`
	Prefix    string             `db:"prefix" json:"prefix"`
	Hash      string             `db:"hash" json:"hash"`
	ExpiresAt pgtype.Timestamptz `db:"expires_at" json:"expires_at"`
	Scopes    []string           `db:"scopes" json:"scopes"`
}

func (q *Queries) CreateAPIKey(ctx context.Context, arg CreateAPIKeyParams) (ApiKeys, error) {
	row := q.db.QueryRow(ctx, createAPIKey,
		arg.UserID,
		arg.Name,
		arg.Prefix,
		arg.Hash,
		arg.ExpiresAt,
		arg.Scopes,
	)
	var i ApiKeys
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Prefix,
		&i.Hash,
		&i.IsActive,
		&i.LastUsedAt,
		&i.ExpiresAt,
		&i.Scopes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteExpiredAPIKeys = `-- name: DeleteExpiredAPIKeys :exec
DELETE FROM api_keys 
WHERE expires_at IS NOT NULL AND expires_at < NOW()
`

func (q *Queries) DeleteExpiredAPIKeys(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredAPIKeys)
	return err
}

const getAPIKeyByHash = `-- name: GetAPIKeyByHash :one
SELECT ak.id, ak.user_id, ak.name, ak.prefix, ak.hash, ak.is_active, ak.last_used_at, ak.expires_at, ak.scopes, ak.created_at, ak.updated_at, u.id as user_id, u.email, u.name as user_name, u.role, u.is_active as user_active
FROM api_keys ak
JOIN users u ON ak.user_id = u.id
WHERE ak.hash = $1 AND ak.is_active = true AND u.is_active = true
`

type GetAPIKeyByHashRow struct {
	ID         uuid.UUID        `db:"id" json:"id"`
	UserID     uuid.UUID        `db:"user_id" json:"user_id"`
	Name       string             `db:"name" json:"name"`
	Prefix     string             `db:"prefix" json:"prefix"`
	Hash       string             `db:"hash" json:"hash"`
	IsActive   bool               `db:"is_active" json:"is_active"`
	LastUsedAt pgtype.Timestamptz `db:"last_used_at" json:"last_used_at"`
	ExpiresAt  pgtype.Timestamptz `db:"expires_at" json:"expires_at"`
	Scopes     []string           `db:"scopes" json:"scopes"`
	CreatedAt  pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt  pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	UserID_2   uuid.UUID        `db:"user_id_2" json:"user_id_2"`
	Email      string             `db:"email" json:"email"`
	UserName   string             `db:"user_name" json:"user_name"`
	Role       string             `db:"role" json:"role"`
	UserActive bool               `db:"user_active" json:"user_active"`
}

func (q *Queries) GetAPIKeyByHash(ctx context.Context, hash string) (GetAPIKeyByHashRow, error) {
	row := q.db.QueryRow(ctx, getAPIKeyByHash, hash)
	var i GetAPIKeyByHashRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Prefix,
		&i.Hash,
		&i.IsActive,
		&i.LastUsedAt,
		&i.ExpiresAt,
		&i.Scopes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID_2,
		&i.Email,
		&i.UserName,
		&i.Role,
		&i.UserActive,
	)
	return i, err
}

const getAPIKeyByPrefix = `-- name: GetAPIKeyByPrefix :one
SELECT id, user_id, name, prefix, hash, is_active, last_used_at, expires_at, scopes, created_at, updated_at FROM api_keys 
WHERE prefix = $1 AND is_active = true
`

func (q *Queries) GetAPIKeyByPrefix(ctx context.Context, prefix string) (ApiKeys, error) {
	row := q.db.QueryRow(ctx, getAPIKeyByPrefix, prefix)
	var i ApiKeys
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Prefix,
		&i.Hash,
		&i.IsActive,
		&i.LastUsedAt,
		&i.ExpiresAt,
		&i.Scopes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAPIKeysByUser = `-- name: ListAPIKeysByUser :many
SELECT id, user_id, name, prefix, is_active, last_used_at, expires_at, scopes, created_at, updated_at
FROM api_keys 
WHERE user_id = $1 AND is_active = true
ORDER BY created_at DESC
`

type ListAPIKeysByUserRow struct {
	ID         uuid.UUID        `db:"id" json:"id"`
	UserID     uuid.UUID        `db:"user_id" json:"user_id"`
	Name       string             `db:"name" json:"name"`
	Prefix     string             `db:"prefix" json:"prefix"`
	IsActive   bool               `db:"is_active" json:"is_active"`
	LastUsedAt pgtype.Timestamptz `db:"last_used_at" json:"last_used_at"`
	ExpiresAt  pgtype.Timestamptz `db:"expires_at" json:"expires_at"`
	Scopes     []string           `db:"scopes" json:"scopes"`
	CreatedAt  pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt  pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) ListAPIKeysByUser(ctx context.Context, userID uuid.UUID) ([]ListAPIKeysByUserRow, error) {
	rows, err := q.db.Query(ctx, listAPIKeysByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAPIKeysByUserRow{}
	for rows.Next() {
		var i ListAPIKeysByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Prefix,
			&i.IsActive,
			&i.LastUsedAt,
			&i.ExpiresAt,
			&i.Scopes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revokeAPIKey = `-- name: RevokeAPIKey :exec
UPDATE api_keys 
SET is_active = false, updated_at = NOW()
WHERE id = $1 AND user_id = $2
`

type RevokeAPIKeyParams struct {
	ID     uuid.UUID `db:"id" json:"id"`
	UserID uuid.UUID `db:"user_id" json:"user_id"`
}

func (q *Queries) RevokeAPIKey(ctx context.Context, arg RevokeAPIKeyParams) error {
	_, err := q.db.Exec(ctx, revokeAPIKey, arg.ID, arg.UserID)
	return err
}

const revokeAllUserAPIKeys = `-- name: RevokeAllUserAPIKeys :exec
UPDATE api_keys 
SET is_active = false, updated_at = NOW()
WHERE user_id = $1
`

func (q *Queries) RevokeAllUserAPIKeys(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, revokeAllUserAPIKeys, userID)
	return err
}

const updateAPIKeyLastUsed = `-- name: UpdateAPIKeyLastUsed :exec
UPDATE api_keys 
SET last_used_at = NOW(), updated_at = NOW()
WHERE id = $1
`

func (q *Queries) UpdateAPIKeyLastUsed(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, updateAPIKeyLastUsed, id)
	return err
}
