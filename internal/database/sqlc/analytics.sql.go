// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: analytics.sql

package sqlc

import (
	"context"
	"net/netip"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const closeInactiveConnections = `-- name: CloseInactiveConnections :exec
UPDATE connections 
SET is_active = false, ended_at = NOW()
WHERE tunnel_id = $1 AND is_active = true AND started_at < $2
`

type CloseInactiveConnectionsParams struct {
	TunnelID  uuid.UUID          `db:"tunnel_id" json:"tunnel_id"`
	StartedAt pgtype.Timestamptz `db:"started_at" json:"started_at"`
}

func (q *Queries) CloseInactiveConnections(ctx context.Context, arg CloseInactiveConnectionsParams) error {
	_, err := q.db.Exec(ctx, closeInactiveConnections, arg.TunnelID, arg.StartedAt)
	return err
}

const countActiveConnections = `-- name: CountActiveConnections :one
SELECT COUNT(*) FROM connections 
WHERE tunnel_id = $1 AND is_active = true
`

func (q *Queries) CountActiveConnections(ctx context.Context, tunnelID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countActiveConnections, tunnelID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createConnection = `-- name: CreateConnection :one
INSERT INTO connections (
    tunnel_id, remote_addr, local_addr, bytes_in, bytes_out
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, tunnel_id, remote_addr, local_addr, is_active, bytes_in, bytes_out, started_at, ended_at
`

type CreateConnectionParams struct {
	TunnelID   uuid.UUID  `db:"tunnel_id" json:"tunnel_id"`
	RemoteAddr netip.Addr `db:"remote_addr" json:"remote_addr"`
	LocalAddr  netip.Addr `db:"local_addr" json:"local_addr"`
	BytesIn    int64      `db:"bytes_in" json:"bytes_in"`
	BytesOut   int64      `db:"bytes_out" json:"bytes_out"`
}

func (q *Queries) CreateConnection(ctx context.Context, arg CreateConnectionParams) (Connections, error) {
	row := q.db.QueryRow(ctx, createConnection,
		arg.TunnelID,
		arg.RemoteAddr,
		arg.LocalAddr,
		arg.BytesIn,
		arg.BytesOut,
	)
	var i Connections
	err := row.Scan(
		&i.ID,
		&i.TunnelID,
		&i.RemoteAddr,
		&i.LocalAddr,
		&i.IsActive,
		&i.BytesIn,
		&i.BytesOut,
		&i.StartedAt,
		&i.EndedAt,
	)
	return i, err
}

const createTunnelAnalytics = `-- name: CreateTunnelAnalytics :one
INSERT INTO tunnel_analytics (
    tunnel_id, requests_count, bytes_in, bytes_out, response_time_avg, error_count
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, tunnel_id, requests_count, bytes_in, bytes_out, response_time_avg, error_count, timestamp
`

type CreateTunnelAnalyticsParams struct {
	TunnelID        uuid.UUID          `db:"tunnel_id" json:"tunnel_id"`
	RequestsCount   int64              `db:"requests_count" json:"requests_count"`
	BytesIn         int64              `db:"bytes_in" json:"bytes_in"`
	BytesOut        int64              `db:"bytes_out" json:"bytes_out"`
	ResponseTimeAvg pgtype.Float4      `db:"response_time_avg" json:"response_time_avg"`
	ErrorCount      int64              `db:"error_count" json:"error_count"`
	Timestamp       pgtype.Timestamptz `db:"timestamp" json:"timestamp"`
}

func (q *Queries) CreateTunnelAnalytics(ctx context.Context, arg CreateTunnelAnalyticsParams) (TunnelAnalytics, error) {
	row := q.db.QueryRow(ctx, createTunnelAnalytics,
		arg.TunnelID,
		arg.RequestsCount,
		arg.BytesIn,
		arg.BytesOut,
		arg.ResponseTimeAvg,
		arg.ErrorCount,
	)
	var i TunnelAnalytics
	err := row.Scan(
		&i.ID,
		&i.TunnelID,
		&i.RequestsCount,
		&i.BytesIn,
		&i.BytesOut,
		&i.ResponseTimeAvg,
		&i.ErrorCount,
		&i.Timestamp,
	)
	return i, err
}

const deleteOldConnections = `-- name: DeleteOldConnections :exec
DELETE FROM connections 
WHERE ended_at IS NOT NULL AND ended_at < $1
`

func (q *Queries) DeleteOldConnections(ctx context.Context, endedAt pgtype.Timestamptz) error {
	_, err := q.db.Exec(ctx, deleteOldConnections, endedAt)
	return err
}

const getActiveConnections = `-- name: GetActiveConnections :many
SELECT id, tunnel_id, remote_addr, local_addr, is_active, bytes_in, bytes_out, started_at, ended_at FROM connections 
WHERE tunnel_id = $1 AND is_active = true
ORDER BY started_at DESC
`

func (q *Queries) GetActiveConnections(ctx context.Context, tunnelID uuid.UUID) ([]Connections, error) {
	rows, err := q.db.Query(ctx, getActiveConnections, tunnelID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Connections{}
	for rows.Next() {
		var i Connections
		if err := rows.Scan(
			&i.ID,
			&i.TunnelID,
			&i.RemoteAddr,
			&i.LocalAddr,
			&i.IsActive,
			&i.BytesIn,
			&i.BytesOut,
			&i.StartedAt,
			&i.EndedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConnectionHistory = `-- name: GetConnectionHistory :many
SELECT id, tunnel_id, remote_addr, local_addr, is_active, bytes_in, bytes_out, started_at, ended_at FROM connections 
WHERE tunnel_id = $1 AND started_at >= $2
ORDER BY started_at DESC
LIMIT $3 OFFSET $4
`

type GetConnectionHistoryParams struct {
	TunnelID  uuid.UUID          `db:"tunnel_id" json:"tunnel_id"`
	StartedAt pgtype.Timestamptz `db:"started_at" json:"started_at"`
	Limit     int32              `db:"limit" json:"limit"`
	Offset    int32              `db:"offset" json:"offset"`
}

func (q *Queries) GetConnectionHistory(ctx context.Context, arg GetConnectionHistoryParams) ([]Connections, error) {
	rows, err := q.db.Query(ctx, getConnectionHistory,
		arg.TunnelID,
		arg.StartedAt,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Connections{}
	for rows.Next() {
		var i Connections
		if err := rows.Scan(
			&i.ID,
			&i.TunnelID,
			&i.RemoteAddr,
			&i.LocalAddr,
			&i.IsActive,
			&i.BytesIn,
			&i.BytesOut,
			&i.StartedAt,
			&i.EndedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTunnelAnalytics = `-- name: GetTunnelAnalytics :many
SELECT id, tunnel_id, requests_count, bytes_in, bytes_out, response_time_avg, error_count, timestamp FROM tunnel_analytics 
WHERE tunnel_id = $1 AND timestamp >= $2 AND timestamp <= $3
ORDER BY timestamp DESC
`

type GetTunnelAnalyticsParams struct {
	TunnelID    uuid.UUID          `db:"tunnel_id" json:"tunnel_id"`
	Timestamp   pgtype.Timestamptz `db:"timestamp" json:"timestamp"`
	Timestamp_2 pgtype.Timestamptz `db:"timestamp_2" json:"timestamp_2"`
}

func (q *Queries) GetTunnelAnalytics(ctx context.Context, arg GetTunnelAnalyticsParams) ([]TunnelAnalytics, error) {
	rows, err := q.db.Query(ctx, getTunnelAnalytics, arg.TunnelID, arg.Timestamp, arg.Timestamp_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TunnelAnalytics{}
	for rows.Next() {
		var i TunnelAnalytics
		if err := rows.Scan(
			&i.ID,
			&i.TunnelID,
			&i.RequestsCount,
			&i.BytesIn,
			&i.BytesOut,
			&i.ResponseTimeAvg,
			&i.ErrorCount,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTunnelAnalyticsSummary = `-- name: GetTunnelAnalyticsSummary :one
SELECT 
    tunnel_id,
    SUM(requests_count) as total_requests,
    SUM(bytes_in) as total_bytes_in,
    SUM(bytes_out) as total_bytes_out,
    AVG(response_time_avg) as avg_response_time,
    SUM(error_count) as total_errors
FROM tunnel_analytics 
WHERE tunnel_id = $1 AND timestamp >= $2
GROUP BY tunnel_id
`

type GetTunnelAnalyticsSummaryParams struct {
	TunnelID  uuid.UUID          `db:"tunnel_id" json:"tunnel_id"`
	Timestamp pgtype.Timestamptz `db:"timestamp" json:"timestamp"`
}

type GetTunnelAnalyticsSummaryRow struct {
	TunnelID        uuid.UUID `db:"tunnel_id" json:"tunnel_id"`
	TotalRequests   int64     `db:"total_requests" json:"total_requests"`
	TotalBytesIn    int64     `db:"total_bytes_in" json:"total_bytes_in"`
	TotalBytesOut   int64     `db:"total_bytes_out" json:"total_bytes_out"`
	AvgResponseTime float64   `db:"avg_response_time" json:"avg_response_time"`
	TotalErrors     int64     `db:"total_errors" json:"total_errors"`
}

func (q *Queries) GetTunnelAnalyticsSummary(ctx context.Context, arg GetTunnelAnalyticsSummaryParams) (GetTunnelAnalyticsSummaryRow, error) {
	row := q.db.QueryRow(ctx, getTunnelAnalyticsSummary, arg.TunnelID, arg.Timestamp)
	var i GetTunnelAnalyticsSummaryRow
	err := row.Scan(
		&i.TunnelID,
		&i.TotalRequests,
		&i.TotalBytesIn,
		&i.TotalBytesOut,
		&i.AvgResponseTime,
		&i.TotalErrors,
	)
	return i, err
}

const updateConnection = `-- name: UpdateConnection :exec
UPDATE connections 
SET bytes_in = $2, bytes_out = $3, is_active = $4, ended_at = CASE WHEN $4 = false THEN NOW() ELSE ended_at END
WHERE id = $1
`

type UpdateConnectionParams struct {
	ID       uuid.UUID `db:"id" json:"id"`
	BytesIn  int64     `db:"bytes_in" json:"bytes_in"`
	BytesOut int64     `db:"bytes_out" json:"bytes_out"`
	IsActive bool      `db:"is_active" json:"is_active"`
}

func (q *Queries) UpdateConnection(ctx context.Context, arg UpdateConnectionParams) error {
	_, err := q.db.Exec(ctx, updateConnection,
		arg.ID,
		arg.BytesIn,
		arg.BytesOut,
		arg.IsActive,
	)
	return err
}

const updateTunnelAnalytics = `-- name: UpdateTunnelAnalytics :exec
UPDATE tunnel_analytics 
SET requests_count = requests_count + $2,
    bytes_in = bytes_in + $3,
    bytes_out = bytes_out + $4,
    error_count = error_count + $5,
    response_time_avg = CASE 
        WHEN requests_count = 0 THEN $6
        ELSE (response_time_avg * requests_count + $6) / (requests_count + 1)
    END
WHERE tunnel_id = $1 AND DATE(timestamp) = CURRENT_DATE
`

type UpdateTunnelAnalyticsParams struct {
	TunnelID        uuid.UUID     `db:"tunnel_id" json:"tunnel_id"`
	RequestsCount   int64         `db:"requests_count" json:"requests_count"`
	BytesIn         int64         `db:"bytes_in" json:"bytes_in"`
	BytesOut        int64         `db:"bytes_out" json:"bytes_out"`
	ErrorCount      int64         `db:"error_count" json:"error_count"`
	ResponseTimeAvg pgtype.Float4 `db:"response_time_avg" json:"response_time_avg"`
}

func (q *Queries) UpdateTunnelAnalytics(ctx context.Context, arg UpdateTunnelAnalyticsParams) error {
	_, err := q.db.Exec(ctx, updateTunnelAnalytics,
		arg.TunnelID,
		arg.RequestsCount,
		arg.BytesIn,
		arg.BytesOut,
		arg.ErrorCount,
		arg.ResponseTimeAvg,
	)
	return err
}
